# Implementation Plan: Project Initiator

**Branch**: `018-project-initiator` | **Date**: 2025-12-20 | **Spec**: [spec.md](./spec.md)
**Input**: Feature specification from `/specs/018-project-initiator/spec.md`

## Summary

An opt-in wizard in the Planning panel that allows users to select a project type and answer quick questions to auto-populate:
- **Objectives**: 4 objectives (functional, quality, budget, program) with variable substitution
- **Disciplines**: Auto-enable consultant disciplines based on project type mappings
- **Program phases**: Create program activities with start/end dates for Gantt chart
- **Cost plan**: Generate preliminary budget line items organized into 4 groups
- **Consultant services**: Generate deliverables by phase for RFT documentation

**Technical approach**: Template-driven generation using external JSON files, modal-based wizard flow, orchestrated initialization via single API endpoint with transaction rollback support.

## Technical Context

**Language/Version**: TypeScript 5.x, React 19, Next.js 15
**Primary Dependencies**: React Query v5, Drizzle ORM (PostgreSQL), Lucide React (icons)
**Storage**: PostgreSQL (via Docker), existing schema extended with `projectType` column
**Testing**: Integration tests for modal flow, template substitution validation, downstream population
**Target Platform**: Web (modern browsers, responsive), Docker containerized
**Project Type**: Next.js App Router (unified frontend)
**Performance Goals**: Type selection < 30 seconds, modal interactions < 100ms
**Constraints**: Existing project creation flow unchanged, opt-in only, no hardcoded templates
**Scale/Scope**: 12 project types, ~50 objective templates, ~15 discipline mappings

## Constitution Check

*GATE: Must pass before Phase 0 research. Re-check after Phase 1 design.*

| Principle | Status | Notes |
|-----------|--------|-------|
| **I. Intelligent Document Repository** | ✅ Pass | Templates stored as JSON files (single source of truth) |
| **II. Domain-First Intelligence** | ✅ Pass | Construction-specific project types and terminology |
| **III. AI-Powered Automation** | ✅ Pass | Template-driven generation with variable substitution |
| **IV. Financial Visibility** | ✅ Pass | Generates preliminary budget integrated with Cost Planning |
| **V. Small Firm Optimization** | ✅ Pass | < 30s setup time, opt-in (no training required), simple 3-step wizard |
| **VI. Sharp, Actionable Outputs** | ✅ Pass | Project-specific objectives via variable substitution |
| **VII. Integration Over Isolation** | ✅ Pass | Integrates with existing modules (Program, Cost Planning, Procurement) |
| **VIII. Test-Driven Quality** | ⚠️ **Action Required** | Must add validation tests (see Testing Strategy below) |
| **IX. Spreadsheet-Native UX** | N/A | Not applicable (modal wizard, not data grid) |

**Action Items for Gate Compliance**:
- Add template substitution validation tests (edge cases, missing variables)
- Add JSON schema validation tests (malformed files, missing keys)
- Add integration contract tests (Program module, Cost Planning module)

## Project Structure

### Documentation (this feature)

```text
specs/018-project-initiator/
├── plan.md              # This file
├── spec.md              # Feature specification
├── tasks.md             # Phase 2 output (created by /speckit.tasks - COMPLETE)
└── [Phase 0/1 artifacts to be generated by /speckit.plan]
    ├── research.md      # Template substitution patterns, conditional logic
    ├── data-model.md    # Complete schema documentation
    └── quickstart.md    # Implementation guide with code samples
```

### Source Code (repository root)

```text
assemble.ai/
├── src/
│   ├── app/
│   │   └── api/
│   │       └── planning/
│   │           └── [projectId]/
│   │               ├── project-type/
│   │               │   └── route.ts        # CREATE: GET/PUT project type
│   │               └── initialize/
│   │                   └── route.ts        # CREATE: POST orchestration endpoint
│   │
│   ├── components/
│   │   └── dashboard/
│   │       └── planning/
│   │           ├── DetailsSection.tsx      # MODIFY: Add ProjectTypeField
│   │           ├── ProjectTypeField.tsx    # CREATE: Clickable field
│   │           ├── ProjectInitiatorModal.tsx  # CREATE: Modal wrapper
│   │           ├── TypeSelectionStep.tsx   # CREATE: Grid of project types
│   │           ├── QuestionsStep.tsx       # CREATE: Dynamic questions
│   │           └── ObjectivesPreviewStep.tsx  # CREATE: Preview & edit
│   │
│   └── lib/
│       ├── data/                           # CREATE: Template JSON files
│       │   ├── project-types.json
│       │   ├── objective-templates.json
│       │   ├── consultant-templates.json
│       │   ├── cost-plan-templates.json
│       │   └── program-templates.json
│       │
│       ├── types/
│       │   └── project-initiator.ts       # CREATE: TypeScript interfaces
│       │
│       └── utils/
│           ├── template-substitution.ts   # CREATE: Variable substitution engine
│           ├── discipline-mapping.ts      # CREATE: Discipline filtering logic
│           ├── program-generation.ts      # CREATE: Program phase generation
│           ├── cost-plan-generation.ts    # CREATE: Cost line generation
│           └── consultant-services-generation.ts  # CREATE: Services/deliverables
│
└── scripts/
    └── run-migration-0021.js              # CREATE: Add projectType column
```

**Structure Decision**: Single Next.js application with App Router. Minimal structural changes - primarily new components in existing `/planning/` directory and new utility modules.

## Architecture Decisions

### 1. Data Model Extensions

**Database Schema Changes** (PostgreSQL via Drizzle ORM):

```typescript
// ALREADY EXISTS in schema.ts line 94
projects.projectType: text('project_type', {
  enum: ['house', 'apartments', 'fitout', 'industrial', 'remediation']
})

// ALREADY EXISTS - projectObjectives table (lines 115-123)
// NO CHANGES NEEDED - objectives stored in existing schema

// ALREADY EXISTS - consultantDisciplines table (lines 166-178)
consultantDisciplines.isEnabled: boolean  // Set to true by initialization
consultantDisciplines.briefServices: text  // Populated from templates
consultantDisciplines.briefDeliverables: text  // Populated from templates

// ALREADY EXISTS - programActivities table (lines 1049-1061)
// Initialization creates parent/child activities with start/end dates

// ALREADY EXISTS - costLines table (lines 378-393)
// Initialization creates lines in 4 sections: FEES, CONSULTANTS, CONSTRUCTION, CONTINGENCY
```

**Migration Strategy**:
- `projectType` column already exists but enum may need expansion
- Create migration script to add any missing project types to enum
- No new tables required - all existing schema supports this feature

**Data Integrity**:
- Project type is optional (NULL allowed) - only populated when user runs wizard
- Objectives, disciplines, program, cost plan can exist independently (no FK to projectType)
- Rollback on initialization failure restores all records to pre-wizard state

### 2. Template Substitution Engine

**Variable Syntax**: `{{variable_name}}`

**Substitution Sources** (priority order):
1. Quick question answers (e.g., `{{building_scale}}`, `{{market_segment}}`)
2. Project details when available (e.g., `{{address}}`)
3. Template defaults for missing values (e.g., `"[not specified]"`)

**Conditional Variations**:
```typescript
interface ObjectiveTemplate {
  functional: string;
  quality: string;
  budget: string;
  program: string;
  variations?: {
    [key: string]: {  // e.g., "purpose"
      [value: string]: Partial<ObjectiveTemplate>;  // e.g., "investment": { functional: "..." }
    }
  }
}
```

**Example**:
```json
{
  "functional": "Deliver a {{building_scale}} residential building...",
  "variations": {
    "purpose": {
      "investment": {
        "functional": "Deliver a {{building_scale}} investment-grade residential building with focus on rental yield..."
      }
    }
  }
}
```

**Implementation**:
```typescript
function substituteVariables(
  template: string,
  answers: Record<string, string | string[]>,
  projectDetails?: ProjectDetails
): string {
  return template.replace(/\{\{(\w+)\}\}/g, (match, key) => {
    // Priority: answers > projectDetails > fallback
    return answers[key] || projectDetails?.[key] || `[${key}]`;
  });
}

function applyVariations(
  baseTemplate: ObjectiveTemplate,
  answers: Record<string, string | string[]>
): ObjectiveTemplate {
  let result = { ...baseTemplate };

  if (baseTemplate.variations) {
    for (const [key, valueMap] of Object.entries(baseTemplate.variations)) {
      const answerValue = answers[key];
      if (answerValue && valueMap[answerValue]) {
        result = { ...result, ...valueMap[answerValue] };
      }
    }
  }

  return result;
}
```

### 3. Integration Contracts

#### A. Program Module Integration (Feature 015)

**Endpoint**: `POST /api/projects/[projectId]/program/activities`

**Contract**:
```typescript
interface ProgramActivityCreate {
  name: string;
  startDate: string;  // ISO date
  endDate: string;    // ISO date
  parentId?: string;  // For child activities
  sortOrder: number;
  color?: string;     // Auto-assigned from muted palette
}

// Batch endpoint for initialization
POST /api/projects/[projectId]/program/activities/batch
{
  activities: ProgramActivityCreate[];
}

Response: {
  activities: ProgramActivity[];
}
```

**Data Flow**:
1. Load phase structure from `program-templates.json` for selected type
2. Apply duration factors from answers (e.g., `building_scale` → 0.6x to 1.3x multiplier)
3. Calculate start/end dates from project start date or current date
4. Create parent activities (phases) with child activities (2-tier structure)
5. Call batch endpoint to create all activities in single transaction

**Duration Factor Calculation**:
```typescript
interface DurationFactor {
  answer_key: string;      // e.g., "building_scale"
  value_multipliers: {     // e.g., "small": 0.6, "large": 1.3
    [value: string]: number;
  };
}

function calculateDuration(
  baseDurationWeeks: number,
  factors: DurationFactor[],
  answers: Record<string, string>
): number {
  let multiplier = 1.0;

  for (const factor of factors) {
    const answerValue = answers[factor.answer_key];
    if (answerValue && factor.value_multipliers[answerValue]) {
      multiplier *= factor.value_multipliers[answerValue];
    }
  }

  return Math.ceil(baseDurationWeeks * multiplier);
}
```

#### B. Cost Planning Module Integration (Feature 006)

**Endpoint**: `POST /api/projects/[projectId]/cost-plan/lines`

**Contract**:
```typescript
interface CostLineCreate {
  section: 'FEES' | 'CONSULTANTS' | 'CONSTRUCTION' | 'CONTINGENCY';
  activity: string;        // Description
  budgetCents: number;
  sortOrder: number;
  disciplineId?: string;   // For CONSULTANTS section
  tradeId?: string;        // For CONSTRUCTION section
  costCode?: string;       // Optional
}

// Batch endpoint for initialization
POST /api/projects/[projectId]/cost-plan/lines/batch
{
  lines: CostLineCreate[];
}

Response: {
  lines: CostLine[];
}
```

**Data Flow**:
1. Load benchmark rates from `cost-plan-templates.json` for selected type
2. Extract project scale from answers (GFA, number of units, etc.)
3. Calculate preliminary budget using formulas (e.g., `GFA * costPerSqm`)
4. Generate line items in 4 groups:
   - **FEES**: Professional fees, authority fees, insurances
   - **CONSULTANTS**: One line per enabled discipline
   - **CONSTRUCTION**: Trade packages based on project type
   - **CONTINGENCY**: Design, construction, client contingencies
5. Apply contingency rates from template (e.g., 10% design, 5% construction)
6. Call batch endpoint to create all lines

**Budget Calculation Example**:
```typescript
interface BenchmarkRate {
  project_type: string;
  calculation_basis: 'gfa' | 'units' | 'fixed';
  rate_per_unit_cents?: number;  // For GFA or units
  fixed_amount_cents?: number;   // For fixed fees
  section: string;
  activity: string;
}

function calculateBudget(
  rate: BenchmarkRate,
  answers: Record<string, string>
): number {
  if (rate.calculation_basis === 'gfa' && rate.rate_per_unit_cents) {
    const gfa = parseFloat(answers.gfa || '0');
    return Math.round(gfa * rate.rate_per_unit_cents);
  }

  if (rate.calculation_basis === 'units' && rate.rate_per_unit_cents) {
    const units = parseFloat(answers.number_of_units || '0');
    return Math.round(units * rate.rate_per_unit_cents);
  }

  return rate.fixed_amount_cents || 0;
}
```

#### C. Consultant Services Integration (Procurement RFT)

**Endpoint**: `PATCH /api/planning/[projectId]/consultants/disciplines/[id]`

**Contract**:
```typescript
interface ConsultantDisciplineUpdate {
  isEnabled: boolean;
  briefServices?: string;      // Markdown formatted list
  briefDeliverables?: string;  // Markdown formatted list
}
```

**Data Flow**:
1. For each enabled discipline, load `deliverablesByPhase` from `consultant-templates.json`
2. Generate services list (summary of scope)
3. Generate deliverables list organized by phase
4. Format as markdown for direct inclusion in RFT Report
5. Update discipline records with generated content

**Deliverables Template Structure**:
```typescript
interface ConsultantTemplate {
  disciplines: {
    [disciplineName: string]: {
      applicableProjectTypes: string[];  // e.g., ["house", "apartments", "all"]
      deliverablesByPhase: {
        [phaseName: string]: string[];   // e.g., { "Concept Design": ["Sketch plans", "3D renders"] }
      };
      typicalServices: string[];         // e.g., ["Design development", "Documentation"]
    }
  }
}
```

### 4. Error Handling Strategy

**Validation Layers**:

1. **Client-side validation**:
   - Required fields in modal steps
   - Question answer validation (at least one option selected)
   - Objectives preview (must have non-empty content)

2. **JSON file validation**:
   ```typescript
   function validateProjectTypesJson(data: unknown): ProjectType[] {
     // Runtime validation of structure
     if (!Array.isArray(data)) throw new Error('Invalid format');

     for (const item of data) {
       if (!item.id || !item.name || !item.category) {
         throw new Error(`Missing required fields in: ${JSON.stringify(item)}`);
       }
     }

     return data as ProjectType[];
   }
   ```

3. **API endpoint validation**:
   - Verify project exists and user has access
   - Validate request body against schema
   - Check referenced entities exist (disciplines, trades)

**Fallback Behavior**:

| Error Scenario | User Experience | Technical Handling |
|----------------|-----------------|-------------------|
| JSON file missing | Toast: "Template data unavailable. Contact support." | Log error, disable wizard |
| JSON parse error | Toast: "Configuration error. Contact support." | Log error with file path |
| Missing template variable | Display `[variable_name]` in preview | Substitute with placeholder |
| API endpoint failure | Toast: "Failed to initialize. Please try again." | Rollback transaction, preserve state |
| Partial initialization | Toast: "Initialization incomplete. Some data may be missing." | Log which step failed, allow retry |

### 5. Rollback/Transaction Strategy

**Problem**: Initialization populates multiple tables (objectives, disciplines, program, cost plan). If any step fails, partial data creates inconsistent state.

**Solution**: Transaction-based orchestration with rollback

**Implementation**:
```typescript
// src/app/api/planning/[projectId]/initialize/route.ts
export async function POST(request: Request) {
  const db = await getDb();

  try {
    await db.transaction(async (tx) => {
      // Step 1: Update project type
      await tx.update(projects)
        .set({ projectType })
        .where(eq(projects.id, projectId));

      // Step 2: Save objectives
      await tx.insert(projectObjectives).values({
        projectId,
        functional: objectives.functional,
        quality: objectives.quality,
        budget: objectives.budget,
        program: objectives.program
      });

      // Step 3: Enable disciplines
      for (const disciplineName of enabledDisciplines) {
        await tx.update(consultantDisciplines)
          .set({
            isEnabled: true,
            briefServices,
            briefDeliverables
          })
          .where(and(
            eq(consultantDisciplines.projectId, projectId),
            eq(consultantDisciplines.disciplineName, disciplineName)
          ));
      }

      // Step 4: Create program activities
      const programResult = await fetch(
        `/api/projects/${projectId}/program/activities/batch`,
        {
          method: 'POST',
          body: JSON.stringify({ activities: programActivities })
        }
      );
      if (!programResult.ok) throw new Error('Program creation failed');

      // Step 5: Create cost plan lines
      const costResult = await fetch(
        `/api/projects/${projectId}/cost-plan/lines/batch`,
        {
          method: 'POST',
          body: JSON.stringify({ lines: costLines })
        }
      );
      if (!costResult.ok) throw new Error('Cost plan creation failed');
    });

    return NextResponse.json({ success: true });

  } catch (error) {
    // Transaction automatically rolls back on error
    console.error('Initialization failed:', error);
    return NextResponse.json(
      { error: 'Initialization failed. No changes were made.' },
      { status: 500 }
    );
  }
}
```

**Rollback Guarantees**:
- ✅ PostgreSQL transaction ensures atomic updates to projects, objectives, disciplines
- ✅ Downstream API calls (program, cost plan) wrapped in transaction
- ✅ ACID compliance guarantees isolation and consistency
- ✅ Any failure rolls back ALL changes
- ✅ User can safely retry initialization without duplicate data

**PostgreSQL Advantages**:
- Superior transaction isolation levels
- Better concurrent access handling for multi-user scenarios
- Native JSONB support for storing template metadata if needed
- More robust constraint validation

### 6. Testing Strategy (Constitution VIII Compliance)

**Required Tests**:

1. **Template Substitution Tests**:
   ```typescript
   describe('substituteVariables', () => {
     it('replaces simple variables', () => {
       const result = substituteVariables(
         'Build a {{scale}} house',
         { scale: 'large' }
       );
       expect(result).toBe('Build a large house');
     });

     it('handles missing variables with fallback', () => {
       const result = substituteVariables(
         'Build at {{address}}',
         {}
       );
       expect(result).toBe('Build at [address]');
     });

     it('applies conditional variations', () => {
       const template = {
         functional: 'Base text',
         variations: {
           purpose: {
             investment: { functional: 'Investment text' }
           }
         }
       };
       const result = applyVariations(template, { purpose: 'investment' });
       expect(result.functional).toBe('Investment text');
     });
   });
   ```

2. **JSON Schema Validation Tests**:
   ```typescript
   describe('JSON template validation', () => {
     it('validates project-types.json structure', () => {
       const data = loadProjectTypes();
       expect(data).toBeInstanceOf(Array);
       expect(data[0]).toHaveProperty('id');
       expect(data[0]).toHaveProperty('quickSetupQuestions');
     });

     it('throws error on malformed JSON', () => {
       expect(() => validateProjectTypesJson('invalid')).toThrow();
     });
   });
   ```

3. **Integration Contract Tests**:
   ```typescript
   describe('Program integration', () => {
     it('creates activities with correct structure', async () => {
       const activities = generateProgramPhases('house', answers);

       expect(activities).toHaveLength(5); // 5 phases
       expect(activities[0]).toHaveProperty('startDate');
       expect(activities[0]).toHaveProperty('endDate');
       expect(activities[0].parentId).toBeNull(); // Top-level
     });
   });

   describe('Cost Plan integration', () => {
     it('generates lines in 4 sections', async () => {
       const lines = generateCostPlan('apartments', answers);

       const sections = [...new Set(lines.map(l => l.section))];
       expect(sections).toContain('FEES');
       expect(sections).toContain('CONSULTANTS');
       expect(sections).toContain('CONSTRUCTION');
       expect(sections).toContain('CONTINGENCY');
     });
   });
   ```

4. **End-to-End Tests**:
   ```typescript
   describe('Initialization flow', () => {
     it('populates all modules on Apply', async () => {
       // Create project
       const project = await createProject();

       // Run initialization
       const response = await fetch(`/api/planning/${project.id}/initialize`, {
         method: 'POST',
         body: JSON.stringify({
           projectType: 'house',
           answers: { building_scale: 'medium', gfa: '250' },
           objectives: { functional: '...', quality: '...', budget: '...', program: '...' }
         })
       });

       expect(response.ok).toBe(true);

       // Verify objectives
       const objectives = await getObjectives(project.id);
       expect(objectives.functional).toBeTruthy();

       // Verify program
       const program = await getProgramActivities(project.id);
       expect(program.length).toBeGreaterThan(0);

       // Verify cost plan
       const costPlan = await getCostLines(project.id);
       expect(costPlan.length).toBeGreaterThan(0);
     });
   });
   ```

## Complexity Tracking

> No constitution violations. This feature extends existing architecture without adding new infrastructure dependencies.

| Aspect | Complexity | Justification |
|--------|------------|---------------|
| New files | 11 | 5 JSON templates + 5 React components + 1 utility module |
| Modified files | 2 | DetailsSection.tsx, schema.ts (projectType enum expansion) |
| New dependencies | 0 | Uses existing React Query, Drizzle, Next.js |
| Database changes | 1 | Expand projectType enum (column already exists) |
| API endpoints | 3 | GET/PUT project type, POST initialize |
| Integration points | 3 | Program module, Cost Planning module, Consultant disciplines |

**Architectural Simplicity**:
- ✅ No new external services or databases
- ✅ No new state management patterns (React Query existing)
- ✅ No new authentication or authorization (inherits project-level)
- ✅ No background jobs or queues (synchronous initialization)
- ✅ Template files are static JSON (no CMS or admin interface)

**Complexity Justification**:
- **5 JSON files**: Required by spec - templates are single source of truth
- **Modal wizard**: Standard pattern for multi-step workflows
- **Integration contracts**: Necessary to populate downstream modules
- **Transaction rollback**: Critical for data integrity (prevents partial initialization)

## Implementation Phases

### Phase 1: Foundation (1 hour)
- Copy JSON files from `Project Initiator/` to `src/lib/data/`
- Verify JSON parsing and structure
- Create TypeScript interfaces in `project-initiator.ts`
- Expand `projectType` enum if needed (migration script)

### Phase 2: Template Engine (2 hours)
- Implement `substituteVariables()` function
- Implement `applyVariations()` function
- Add validation tests for edge cases
- Document conditional logic patterns

### Phase 3: Modal Components (6 hours)
- Create `ProjectInitiatorModal.tsx` wrapper
- Build `TypeSelectionStep.tsx` (grid + filters)
- Build `QuestionsStep.tsx` (single/multi select)
- Build `ObjectivesPreviewStep.tsx` (editable preview)
- Add loading states and error handling

### Phase 4: API Endpoints (3 hours)
- Create `GET/PUT /api/planning/[projectId]/project-type`
- Create `POST /api/planning/[projectId]/initialize`
- Implement transaction-based orchestration
- Add error handling and rollback logic

### Phase 5: Downstream Generation (8 hours)
- Implement `discipline-mapping.ts` (auto-enable logic)
- Implement `program-generation.ts` (activity creation with duration factors)
- Implement `cost-plan-generation.ts` (benchmark calculations)
- Implement `consultant-services-generation.ts` (deliverables formatting)
- Add integration tests for each module

### Phase 6: Integration & Polish (3 hours)
- Integrate `ProjectTypeField` into `DetailsSection.tsx`
- Wire up modal → API → refresh flow
- Add success/error toast notifications
- Verify existing project creation flow unchanged

### Phase 7: Testing & Validation (2 hours)
- Run all integration tests
- Verify constitution compliance (test coverage)
- Performance testing (< 30s target)
- Edge case testing (missing data, malformed JSON)

**Total Estimated Effort**: 25 hours

## Generated Artifacts

| Artifact | Path | Status |
|----------|------|--------|
| Specification | `specs/018-project-initiator/spec.md` | ✅ Complete |
| Implementation Plan | `specs/018-project-initiator/plan.md` | ✅ Complete (this file) |
| Tasks | `specs/018-project-initiator/tasks.md` | ✅ Complete |
| Research | `specs/018-project-initiator/research.md` | ⏳ Pending |
| Data Model | `specs/018-project-initiator/data-model.md` | ⏳ Pending |
| Quickstart | `specs/018-project-initiator/quickstart.md` | ⏳ Pending |

## Risk Assessment

| Risk | Likelihood | Impact | Mitigation |
|------|------------|--------|------------|
| JSON templates become stale | Medium | Low | Document update process, add schema validation |
| Initialization fails partway | Medium | High | ✅ Transaction rollback implemented |
| Variable substitution edge cases | High | Medium | ✅ Comprehensive test coverage |
| Integration contract breaks | Low | High | Add contract tests, version module APIs |
| Performance degrades (> 30s) | Low | Medium | Batch API calls, optimize template loading |
| Existing flow accidentally modified | Low | Critical | ✅ Tests verify flow unchanged |

## Success Metrics

| Metric | Target | Measurement |
|--------|--------|-------------|
| Time to set project type | < 30 seconds | Track modal open → Apply duration |
| Objectives accepted without edits | > 70% | Track Apply clicks without objective edits |
| Projects with type → have objectives | > 90% | Query: COUNT(projects WHERE projectType IS NOT NULL AND objectives exist) |
| Existing creation flow speed | Unchanged | Compare before/after benchmarks |
| Test coverage | > 80% | Code coverage for utilities and API routes |

## Next Steps

1. ✅ **Plan Complete** - This document satisfies constitution requirement
2. **Run `/speckit.implement`** - Begin implementation following tasks.md
3. **Phase 0: Generate research.md** - Document conditional logic patterns and duration factor formulas
4. **Phase 1: Generate data-model.md** - Complete schema documentation with examples
5. **MVP Checkpoint** (after Phase 9) - Demo core flow (type → questions → objectives) before downstream integration
